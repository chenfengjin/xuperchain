只读事务场景跨链
==========
整体方案
>>>>>>>>>>>>

在大部分使用场景下，用户仅希望从一个链能够查询到另一个链的数据，并且能够满足稳定性、幂等性和安全性，我们称为只读事务跨链。

只读事务跨链的典型场景包括身份认证、资质认证等；

为了满足上述要求，我们采取了目标链背书的方式，如下图所示：

.. image:: /images/cross_chain_9.png
    :align: center

完整的步骤如下：

1. 用户在原链发起预执行，合约内部调用”cross_query”原语，访问目标链Hello()合约；
#. 原链内部解析到”cross_query”原语后会调用跨链寻址合约解析目标链链接和背书信息；
#. 原链访问目标链的背书服务；
#. 目标链背书服务内部访问Hello()合约，得到Response并进行签名，返回给原链；
#. 原链继续执行合约，并返回预执行结果给用户；
#. 用户组装完整的交易提交给原链网络；

背书和验证
>>>>>>>>>>>>>>>>>>>
超级链的合约采用的是先预执行再提交的二阶段处理过程，参看 （https://xuperchain.readthedocs.io/zh/latest/design_documents/XuperModel.html）。

**预执行阶段**，原链节点会远程访问目标链背书服务，背书服务会预执行该合约并且对合约结果进行签名背书，原链会将该合约的结果和背书信息写进写集中一个特殊的bucket中。

**提交阶段**，不需要再进行远程调用，原链节点在验证合约时，首先会解析出该特殊的写集中的跨链结果和背书签名信息，以填充合约执行的上下文环境，当执行到只读跨链原语时，原链节点不再进行远程调用，而是验证预执行的背书签名，当签名满足背书策略的要求后，就直接使用写集中的跨链合约结果继续后续的合约逻辑，否则验证失败。

使用说明
>>>>>>>>>>>>>>

	https://xuperchain.readthedocs.io/zh/latest/advanced_usage/readonly_queries.html

