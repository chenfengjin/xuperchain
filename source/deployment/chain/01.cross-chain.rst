跨链基本概念
====

什么是跨链
-----------------
近年来，随着区块链行业的蓬勃发展，产生了很多区块链系统，这些系统底层协议各不相同。并且随着区块链被被纳入新基建的范畴， 如火如荼的区块链改造运动更加活跃，正在形成一个个新的数据孤岛无论这些孤岛是基于相同的底层系统还是不同的底层系统，其数据互通都非常困困难，因此，迫切需要一个解决方案能够系统地解决多链之间融合的问题，从而实现不同链之间地价值互通。

跨链（Cross-Chain），简单来说就是通过一定的技术措施实现相对独立的不同区块链系统之间数据和资产的链接互通。常见的跨链解决方案一般是针对资产类，实现不同链之间任意数据的跨链互通难度会更高

常见的跨链互操作类型
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

跨链资产互换
>>>>>>>>>>>>>>>>>>>
.. image:: /images/cross_chain_1.png
    :align: center

跨链资产转移
>>>>>>>>>>>>>>>>>>>>
.. image:: /images/cross_chain_2.png
    :align: center

跨链任意数据
>>>>>>>>>>>>>>>>>>
.. image:: /images/cross_chain_3.png
    :align: center

主流跨链方案
-------------------

跨链技术的主要挑战
^^^^^^^^^^^^^^^^^^^^^^^^^

    - 生效的原子性
      对两个网络分别发起交易tx1、交易tx2，如何保证要么都不生效，要么都生效。可以通过经典的两阶段提交来完成， 两个交易互为锚点，锚点超过一段时间仍然无效，就可以发起对交易的回滚。

    - 锚点有效性校验
      所有节点对锚点的有效性达成没有分歧的判断，不能依赖远程访问证明，由于网络不稳定因素可能会造成验证难的问题。

    - 合约验证的不确定性
      一般的区块链系统，每个节点都会验证交易，以防止作恶。所以如果一个合约嵌入了外部链的合约调用，那么在验证阶段，如何确保各个节点验证的结果的一致性，是否会依赖外链的稳定性，这些问题都需要解决。

主流的跨链方案
^^^^^^^^^^^^^^^^^^^^^^^^^

一般地通过哈希时间锁可以保证跨链交易的原子性。对于两个比较独立的区块链系统，一般的需要依赖一个第三方组件实现信息的交互。根据第三方组件是否执行验证可以分为两种模式，分为公证人模式、侧链/中继模式和哈希锁定模式。根据不同链的交易是异步生效还是同步生效，可以分为异步模式和同步模式。

公证人模式
>>>>>>>>>>>>>>>

由一个或者一组节点作为公证人参与到两条链中，进行双方交易的收集和验证。其优点是简单，缺点是弱中心化，如下图所示：

.. image:: /images/cross_chain_4.png
    :align: center

侧链/中继模式
>>>>>>>>>>>>>>>>>

侧链/中继链模式是2014年BlockStream提出的一种跨链方案。其与公证人模式最大的区别在于其验证是在目标链进行，通过双向锚定的方式实现资产在不同链之间的转移。目标链的验证方式各不相同，比如BTC-Relay使用的是SPV技术。

.. image:: /images/cross_chain_5.png
    :align: center

异步模式
>>>>>>>>>>>>>>

以太坊上很多预言机类的DApp的实现方式采用的是异步模式。简单来说，是指发起调用的是一个函数，处理调用结果的是另一个回调函数，如下图所示：

.. image:: /images/cross_chain_6.png
    :align: center

异步调用场景下，一个完整流程需要3笔交易：首先发送交易tx1到A链，A链代码执行到跨链调用会发出一个事件，并且声明了回调函数。

由一个中间件（单例）订阅到事件后，发起对B链调用的交易tx2，tx2上链成功后， 中间件在触发回调函数调用Tx3.

异步的缺点是业务逻辑被迫拆成很多碎片，交互次数多，编程不友好。

同步模式
>>>>>>>>>>>>>>
同步模式目前业界没有比较统一的方案，一般地区块链的上的合约在每个节点都会重复执行，如何保证重复执行的结果确定性，且具备幂等性、无副作用是一个难解决的问题。但是现在很多区块链系统采取的是预执行再提交的方式，比如超级链和Fabric，基于这种事务模式比较容易同步模式的跨链，下面是同步模式的示意图：

.. image:: /images/cross_chain_7.png
    :align: center

超级链跨链方案
-----------------------
超级链是一个易于编程的区块链框架，可以方便地定制新的功能。基于此框架，超级链设计了一个轻量级的跨链方案，通过合约和一些基础库组成了一个完整的跨链方案，适用于不同的跨链应用场景。

.. image:: /images/cross_chain_8.png
    :align: center

超级链的跨链方案主要包括3层， 分别是基础库层、账本层和合约层。其中基础库层和账本层属于超级链的内核层，是超级链框架提供的一些基础能力，包括跨链域名解析协议、梅克尔proof校验、异构区块头解析协议、事务预锁定等。合约层是使用用户合约实现的合约基础库，主要是区块头管理合约、链名解析合约、去中心化身份管理等能力。通过这些功能套件的组装，我们可以应用于不同的使用场景。

通过对用户实际需求的调研，我们抽象出三种不同的跨链场景，分别是只读事务场景跨链、非事务场景跨链和事务场景跨链。并通过上述合约和基础库的能力设计了满足不同场景的解决方案，下面会进行详细的介绍。

跨链域名解析
^^^^^^^^^^^^^^^^^^^
跨链涉及到不同链资源的互操作，由于不同的链的协议各部相同，为了实现对不同链的资源进行统一定义，超级链定义了如下跨链寻址协议，结合着链名解析合约，便可以实现对任何协议链的统一资源寻址。

跨链寻址协议
>>>>>>>>>>>>>>>>>

.. code-block:: c++
	:linenos:
	
	    [chain_scheme:][//chain_name][path][?query]
		
- chain_scheme：跨链链类型标识符，用于标识链的具体类型，比如： xuper 表示所跨链链接的链的类型是超级链。
- chain_name：所跨链的链名，定位某一个具体的链，同一Scheme下链名是唯一的；
- path：不同Scheme的链类型扩展字段；
- query：用于定位某个链内的某项资源，比如对于超级链，声明调用的合约名、方法名和参数等信息；
	
	下面举例说明：
	::
		
		xuper://chain1?module=wasm&bcname=xuper&contract_name=counter&method_name=increase
		xuper: 表示被访问的目标链为XuperChain；
		chain1: 表示被访问的目标链的链名；
		module: 表示被访问目标xuper链被访问合约的vm为wasm;
		bcname: 表示被访问目标xuper链的子链名；
		contract_name: 表示被访问目标xuper链合约名；
		method_name：表示被访问目标xuper链合约方法名；
		
目前超级链仅开源了超级链搭建的网络之间的跨链互操作，后续会逐步开源与其他链之间的互操作能力。

链名解析合约
>>>>>>>>>>>>>>>>>

为了实现跨链请求，仅有上面的链名跨链寻址协议是不够的，在跨链发起的原链上还需要部署一个链名解析合约，该合约目前也已开源 `链名解析合约 <https://github.com/xuperchain/xuperchain/blob/master/core/contractsdk/cpp/example/naming/src/naming.cc>`_。

.. code-block:: go
	:linenos:
		
	// 注册一个网络，同时包含网络初始meta信息
	RegisterChain(name, chain_meta)  
	// 更新一个网络的meta信息，比如修改网络的背书策略
	UpdateChain(name, chain_meta)  
	// 根据网络名解析所有背书节点
	Resolve(chain_name) *CrossQueryMeta 
	// 插入一个背书节点
	AddEndorsor(chain_name, info) 
	// 更新背书节点信息
	UpdateEndorsor(chain_name, address, info)
	// 删除背书节点
	DeleteEndorsor(chain_name, address) 
	// 目标网络meta信息
	message CrossChainMeta {
		string type = 1;
		int64 min_endorsor_num = 2;
	}
	// 目标网络背书信息
	message CrossEndorsor {
		string address = 1;
		string pub_key = 2;
		tring host = 3;   // ip+port
	}
	// 目标网络CrossQuery完整信息
	message CrossQueryMeta {
		CrossChainMeta chain_meta = 1;
		repeated CrossEndorsor endorsors = 2;
	}
	